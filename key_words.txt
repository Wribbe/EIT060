#use EIT060_words.txt

UMTS, extent of nonrepudation
buffer overflow, unsafe functions, return address, buffer size
spoofing attack, prevention, detection
WEP, confidentiality, integrity, authentication
UID, real, effective, Linux
policy conflict, groups, Linux vs Windows
difference, Bell-LaPalda, Biba
ESP-package, encryption, ip-header, tunnel mode, transport mode
firewall, packet filter, stateful packet filter
orange book vs Common criteria, product functionality, product assurance
SSL, 3x2 keys, Client, Server, CA
Needham-Schroeder, security flaw
Kerberos
cryptographic strength, empirically secure, provably secure, unconditionally secure
Birtday paradox
Messenger Authentication Code (MAC)
FFR (biometric systems)
inference (statistics database)
Chinese wall security model.

diff, access control list, capabilities
drwxrwxrwt vs drwxrwxrwx
Orange Book vs ITSEC vs Common Criteria: functionality, assurance -> products
replay attack, protection in SSL handshake
Encrypt Key Exchange (EKE), omit password, modified EKE
ESP header, ?not encrypted in IPsec transport mode
IDS (Intrusion Detection System), missuse detection, anomaly detection
IDS (Intrusion Detection System) vs honeypot: false negatives, false positives
Biba -> !x(clean, dirty)
RSA, public modulus, public exponent, break-find private exponent
Diffie-Hellman, !desc(), !desc(man in the middle), !desc(stop Diffie-Hellman man in the middle)
!diff(/etc/passwd, /etc/shadow)
!diff(LM, NTLM)hashes.
!diff(Linux vs Windows) -> salt use
!expl(random salt) -> protection time-memory attack
!defi(both entries, channel, authenticated)
!expl(network authenticated) -> UMTS
!expl(server authentication, SSL) -> RSA as handshake
!expl(Controlled Invocation)
!expl(HMAC)
!expl(Chinese Wall Model)
!expl(Spoofing Attack)
!expl(Canary Value)

!expl(benefit known randomness) -> [initialization vectors (IV), salt, nonce]
!expl(lack of authentication of client) -> SSL/TLS webpage
!desc(two security differences) -> [LM,NTLM]
!desc(ss-property, *-property, ds-property) -> Bell-LaPadula
!desc(canary value) -> detecting a buffer overflow attack
!desc(buffer overflow prevention)
!diff(tunnle vs transport)-mode ->  IPsec
!expl(IPsec protects, replay attacks)
!diff(anomaly, missuse)-detection -> IDS
!diff(Orang book vs ITSEC vs Common Creteria) -> [functionality, assurance]
!expl(WEP,CRC-32,ICV,RC4) -> integrity protection
!expl(attacker chosen challenge) -> [[TMTO,MITM]-attack],HMAC]
!expl(known challenge not sufficient) -> TMTO-attack
!expl(challenge,HMAC,random number addition) -> change in protocol security
!expl(startpoint,endpoint,function) -> [TMTO, rainbow]-tables
!desc(largest password can be broken, online attack) -> [T=2^24,M=2^24]
!expl(PBKDF2()) -> improved security of protocol
!expl([primage,second preimage, collision]-resistance]) -> n-bit hash function
!desc(inputs <-> collision) -> n-bit hash function
!desc(inputs <-> second preimage) -> n-bit hash function
!expl(ruid) -> process executes rwsrwxrwx alice:root prog
!expl(euid) -> process executes rwsrwxrwx alice:root prog
!expl(delete permissions) -> -rwsrwzrwx alice:root prog
!expl(listing of new non-exec file) -> umask 027
!expl(x) -> -rwsrwxrwx
!desc(Reference monitor)
!desc(Clark-Wilson)
!desc(CBS mode)
!desc(Security descriptor)
!desc(inode)

#--- Slides ----

#--- Lecture #1 ---

!diff(ITSEC vs Clark and Wilson vs Oragne Book) -> Integrity
!answ(ITSEC: prevent unauthorized writing,
      Clark and Wilson: never possible to destroy/corrupt co. assets or data,
      Organge book: Statebased\, exists when data == source and never exposed to alteration or destruction)

!desc(Integrity) -> communications
!answ(dete. and corr. inte. or rand. mod. in trans.)

!desc(Integrity) -> general case
!answ(ever. should be as it is supp. to be.)

!desc(four ways to achi. integerity)
!answ(CRCs, hash funcs., Mess. Auth. Codes, digi. sigs.)

!expl(Accountability) -> Orange Book
!answ(aduit, possible to trace security actions to responsible party)

!expl(Nonrepudiation of-[ origin, receipt])
!answ(Origin: can't deny sending information,
      Reciept: can't deny receiving information)


#--- Lecture #2 - #3 (13*4 = 52 slides) ---
#layout:
#  * Cryptography
#    * Keys
#      - symmetric
#      - public
#      * security
#        - RSA
#    * Primitives
#    * Encryption strength
#    * Plain- and cipher-text
#    * Ciphers
#      - Vigenere
#      - substitution
#      - one-time-pad
#      - stream
#      - block
#    * Hash functions
#    * Message Authentication Codes (MAC)
#      - properties
#    * Signatures
#    * Certificates

!expl([Empirically,Provably,Unconditionally]-secure -> Encryption mechanics strength.
!answ(Empirically: No one has broken it for some time,
      Provably: Breaking at least as hard as other common problem,
      Unconditionally: Secure with unlimited data-power)

!desc([Plain,Cipher]-text)
!answ(Plain: the text that user wants to send,
      Cipher: the actual text that gets sent)

!expl(Stream cipher)
!answ(Short random key is expanded to long (pseudo)random bit sequence)

!expl(Block cipher)
!answ(Substitution with larger tables\, map text- to cipher-symbols with math)

!diff(ECB vs CBC) -> cipher encryption.
!answ(Electronic Code Book: each block encrypted in isolation\, redundancy,
      Cipher Block Chaining: previous block input to current\, redundancy gone)

!expl(Public key- or asymmetric-cryptography) -> encryption and decryption
!answ(2x keys\, public=encrypt\, private=decrypt)

!expl(Public key- or asymmetric-cryptography) -> digital signatures
!answ(2x keys\, public=verification\, private=signing)

!desc(Defining properties of a hash funciton)
!answ(Easy to compute\, compression arbitrary to fixed length)

!desc(Preimage resistance / one-way) -> Hash function
!answ(infeasible to reconstruct x from y h(x)=y)

!desc(Second preimage resistance / weak collision resistance) -> Hash function
!answ(given x and h(x)\, infeasible to find x' such that h(x)=h(x'))

!desc(Collision resistance / strong collision resistance) -> Hash function
!answ(infeasible to find x, x' such that h(x)=h(x'))

!desc(keyed hash function) -> MAC
!answ(Computed from message and key)

!desc(Purpose of MAC?)
!answ(Proves integrity of message)

!expl(Ease of computation,Compression,Computation resistance) -> MAC properties
!answ(Ease of computation: given k and x, h_k(x) easy to compute,
      Compression: arbitrary input length to fixed output length,
      Computation resistance: given pairs x_p, h_k(x_i) infeasible to compute
                              pair (x, h_k(x)) with new message x)

!expl(nonrepudiation)
!answ(An action should be tied to a unique individual)

!desc(Public verification key) -> RSA signatures
!answ(n,d)

!desc(Private signing key) -> RSA signatures
!answ(e,p,q)

!desc(Signing) -> RSA signatures
!answ(Hash message M: m=h(M) and sign y s= m^e mod n)

!desc(Verification given s and m) -> RSA signatures
!answ(check if s^d = m mod n)

!diff([symmetric vs asymmetric]-algorithms) -> speed
!answ(symmetric are ~ x1000 faster)

!diff([symmetric vs asymmetric]-algorithms) -> security
!answ(Asymmetric key of 1024 ~= 80 symmetric)

!diff(MAC vs digital signaturs) -> keys
!answ(MAC: secret key can sign and verify,
      Signature: One can sign all can verify)

!expl(MAC, Digital Signatures) -> prerequisites for usage
!answ(MAC: pre-shared key,
      Digital Signatures: digital certificates)

# --- lecture 4 - Indentification and Authentication (10*4 + 1 = 41) ---
#layout:
#* Username
#* Password
#  - password file
#  - salting
#* Attacks
#  - spoofing
#  - brute force
#  - dictionary
#  - time memory trade off (TMTO)
#  - rainbow table
#* Biometrics
#  - False Acceptance Rate
#  - False Rejection Rate

!desc(unilateral authentication) -> username and password
!answ(System can authenticate user but not reverse)

!desc(prevention methods) -> spoofing attacks
!answ(Trusted path (CTRL+ALT+DEL)\, mutual authentication\, one time passwords)

!desc(detection methods) -> spoofing attacks
!answ(Information about previous login sessions\, display number of failed logins)

!expl(brute force attack)
!answ(try entering or hashing all possible passwords)

!desc(prevention methods) -> brute force attacks
!answ(have a slow hash function)

!expl(dictionary attack)
!answ(try combinations of different words from dictionaries)

!expl(time-memory tradeoff attack)
!answ(bruteforce with a precomputed table in memory for faster lookup)

!desc(phases of a TMTO)
!answ(1: preprocessing phase,
      2: realtime/online phase)

!desc(reduction function) -> TMTO
!answ(Not actual reverse of hash\, map hashvalue to plaintext)

!expl(the matrix stopping rule) -> TMTO
!answ(mt^2=N where N is the search space size)

!desc(realtime phase) -> TMTO
!answ(1: Use R(h(R(h(x))))... on hash until endpoint is found,
      2: Iterate over h\->R cycle until h(x) is encounter\, previous x is password)

!desc(Realtime computation needed) -> TMTO
!answ(T=t^2)

!desc(Preprocessing time needed) -> TMTO
!answ(P=N)

!desc(Memory needed) -> TMTO
!answ(M=mt)

!diff(Rainbow Tables vs TMTO)
!answ(Rainbow tables use different R-func for each link in a chain)

!desc(advantages) -> salting passwords
!answ(1: slows dictionary attacks with several passwords at once,
      2: Attacker needs Rainbow table for each salt,
      3: same password different hash)

# --- lecture 5 - Access Control (4*6 + 3 = 27) ---
#layout:
#*Subject
#*Objects
#*Access operations
#*Access control structures
#*Intermediate controls

!expl(subject,object,access operation,reference monitor) -> Access Control
!answ(subject: active ex. users and processes,
      object: passive ex. files and resources,
      access operation: ex. read and write,
      reference monitor: grants/denies access)

!diff(execute vs append vs read vs write) -> observe and alter in Bell-LaPadula
!answ(execute: [ ] [ ],
      append: [ ] [x],
      read: [x] [ ],
      write: [x] [x])

!expl(read,write,execute) -> File in Linux
!answ(read: read file,
      write: write file,
      execute: execute program)

!expl(read,write,execute) -> Directory in Linux
!answ(read: list directory,
      write: create/delete/rename files,
      execute: search directory)

!expl([discretionary,mandatory]-{access control}) -> General security policy
!answ(discretionary: owner of object decides access rights,
      mandatory: system decides access rights)

!expl([discretionary,mandatory]-{access control}) -> Orange Book
!answ(discretionary: restrict access based on identity of subject,
      mandatory: restrict access based on information sensitivity of object
                 and authorization level of subject)

!diff(Capabilities vs Access Control List) -> Access Control Matrix
!answ(capabilities: store access rights with subjects,
      access control list: store access rights with objects)

!expl(drawbacks) -> capabilities and access control list
!answ(capabilities: difficult to determine who has access to given object,
      access control list: difficult to determine single users permission)

!expl(Principle of least privilege)
!answ(a subject should only have access to necessary resources)

!expl(Separation of duties)
!answ(critical security functions must be preformed by more than one user)

!expl(Role-base access control)
!answ(derive access from users current role)

!desc(RBAC0)
!answ(contains user\, roles\, permission and session)

!desc(RBAC1)
!answ(allows inheritance)

!expl(mutually exclusive roles, cardinality, prerequisite) -> RBAC2
!answ(mutually exclusive roles: separation of duties,
      cardinality: restrictions such as one manager per project or
                   max number of roles per user,
      prerequisite: need to have a previous role possible to implement
                    principle of least privileged)

!desc(RBAC3)
!answ(RBAC1+RBCA2 combining inheritance with constraints)

!expl(domination) -> Lattice of security levels
!answ(b dominates a if a <= b\, a is a subset of b)

!expl(least upper bound: u) -> Lattice of security levels
!answ(least upper bound is the nearest element that contains the elements\,
      if a={x} and b={z} then u={x,z})

!expl(greatest lower bound: l) -> Lattice of security levels
!answ(greatest lower bound is nearest common sub-element\,
      if a={x,y} and b={x,z} then l={x})

!expl(Reference monitor)
!answ(abstract machinery that controls all access to objects)

!expl(Security kernel)
!answ(hardware\, software etc that implements reference monitor concept)

!expl(Trusted computing base)
!answ(set of all protection mechanisms enforcing security policy)

!desc(requirements) -> Reference monitor
!answ(Tamper proof\, always invoked\, allow analysis by being small)

!expl(Controlled invocation) -> users access rights
!answ(supply elevated actions through API that does predefined set of operations)

#--- Lecture 6 - Windows security (4*9 = 36) ---
#layout:
#*Design motivation
#*Login procedure(simplified)
#*Related files
#*Accounts
#  - local
#  - domain
#*Hashes
#  - NTLM
#  - LM
#*Access
#  - control
#  - tokens
#  - rights
#  - mask
#  - control / Network shares
#*Identification
#  - SID
#  - Security Descriptor
#    - DACAL
#    - SACL
#*Privileges
#  - user account control
#  - mandatory access control

!desc(What LSA handles) -> Windows Logon
!answ(Local Security Authority handles log in\, password policies\,
      privileges\, audition preferences etc)

!expl(SAM) -> Passwords
!answ(Password hashes are stored in SAM (Security Accounts Manager))

!desc(What is stored in the SAM?)
!answ(Username\, Full name\, Expiration date\, password dates\, logon hours\,
      profile path and logon script name\, home directory\, groups)

!desc([Local vs Domain]-accounts) -> authentication protocol
!answ(Local: NTLM,
      Domain: Kerberos V5)

!desc(NTLM vs Kerberos V5) -> domain authentication
!answ(Kerberos: mutual authentication\,
      NTLM: unilateral authentication)

!desc(problem with NTLM hash)
!answ(MD4 fast hash function\, no salt used)

!desc(problem with LM hash)
!answ(DES fast block cipher\,
      no salt\,
      password up to 14 no better than 7\,
      no lowercase chars)

!desc(Three parameters of authentication) -> Access Control
!answ(Identity of subject\, type of access\, object security setting)

!desc(Fields present in access token)
!answ(User SID (identity of subject)\,
      SIDs of groups the user is member of\,
      privilege list\,
      default DACL\,
      Owner\,
      Group\,
      Miscellaneous)

!diff([primary,impersonation]-{access token})
!anws(primary: access token of user account associated with process,
      impersonation: thread can execute in elevated context)

!expl(S-R-I-SA-SA-SA-N) -> Security Identifier (SID)
!answ(S: letter S\,
      R: revision number (1)\,
      I: identifier authority (5 for user accounts)\,
      SA: subauthority (specifies domain or computer\, usually 3 groups),
      N: relative identifier\, incremented for each new principal)

!desc(S-1-1-0) -> SID
!answ(Everyone, a group that includes all users)

!desc(S-1-5-SA-SA-SA-501) -> SID
!answ(Guest account no password)

!desc(S-1-5-SA-SA-SA-500) -> SID
!answ(Administrator)

!desc(operations, application, assignment access check) -> Privileges Windows
!answ(operations: system related ex shut down,
      application: applies to local computer,
      assignment: can be assigned to both users and groups,
      access check: access token check when try preform privileged operation)

!diff(privileges vs access rights) -> Windows
!answ(gives access to resources + tasks\, not objects\,
      stored with subject\,
      admin assigns privileges)

!desc(Application scope of privileges)
!answ(Applies to local computer)

!diff(Resources vs Objects) -> Windows
!answ(All resources are objects\, ex files\, folders\, printers)

!desc(Securable object) -> Objects Windows
!answ(any object that can be shared\, might include security descriptor)

!desc(Fields) -> Security Descriptor
!answ(Owner SID\,
      Primary group SID\,
      DACL\,
      SACL)

!desc(Purpose of DACL) -> Windows
!answ(Identify allowed or denied access to object)

!desc(Contents of DACL) -> Windows
!answ(List of access control entries (ACEs) where a SID allowed/denied access)

!diff(non existent vs empty) -> DACL
!answ(non existent: everyone full control,
      empty: everyone denied)

!expl(Access precedence) -> DACL
!answ(deny has higher precedence than allow)

!expl(DACL search routine)
!answ(go through ACEs until all allowed or any denied)

!expl(Result user denied w group w+r) -> DACL
!answ(denied w+r)

!desc(Access Control) -> Network Shares
!answ(two ACLs too access file\, 1x on share\, 1x on file)

!diff(Capabilities vs Access Control Lis)
!answ(capabilities: store access right with subject\, privileges,
      access control list: store access rights with object\, access rights)

!desc(restricted token) -> restricted context
!answ(Applications can start process with restricted token\,
      Process can start process or thread with restricted token\,
      can be primary or impersonation token)

!expl(Type of restrictions) -> restricted context
!answ(Remove privileges\, set deny-only attributes to SIDs\,
      Specify restricting SID)

!desc(how to) -> restricting a token
!answ(use group SID as deny only and add restricted SID\,
      two access checks\, both must allow access\, otherwise denied)

!desc(User Account Control) -> number and type of tokens
!answ(administrators get 2x tokens\, user and admin\,
      user has to acknowledge use of admin token)

!desc(Mandatory access control and levels) -> Windows
!answ(Integrity Control with [untrusted,low,medium,high,system]-integrity\,
      where medium is normal user with UAC)

!expl(SACL and its defaults) -> Windows mandatory access control
!answ(object can store integrity level in SACL\,
      access token < medium: integrity = token,
      access token >= medium: integrity = medium)

!desc(SACL integrity level) -> write operations
!answ(Subjects integrity dominates objects integrity\, checked before DACL)

# -- UNIX (and Linux) Security (34) --
#layout:
#*Crypt
#  - Traditional
#  - MD5
#  - bcrypt
#*Password storage
#  - Authentication
#  - /etc/password
#  - /etc/shadow
#*Access Control
#  - Users
#  - UIDs for Processes
#  - groups
#  - check order
#  - directory permissions
#  - umask
#  - chown
#  - chgrp
#*Permissions
#  - chmod
#  - setuid & setgdi
#    - programs
#    - directories
#  - important SUID programs
#  - sticky bit
#*Filesystem
#  - inode
#  - mounting
#  - searchpath

!expl(relation UID and name) -> UNIX access level
!answ(Accounts with different name but same ID are treated the same)

!desc(superuser UID) -> UNIX
!answ(0)

!expl(storage of UID) -> UNIX
!answ(/etc/password)

!diff([real vs effective]-{user ID}
!answ(real: ID of the logged in principal (only root can change),
      effective: ID used for access control\, can be changed to anything
      by root and can be changed back to real userID by anyone)

!expl(Usage of groups) -> multiple ID access to file
!answ(Can't associate multiple IDs with file\, put all IDs in group\,
      give file access to group)

!diff(primary vs other) -> group storage
!answ(primary: /etc/passwd,
      other: /etc/group)

!desc(traditonal crypt) -> password hashing UNIX
!answ(DES-based\, max 8 char + 12bit salt\, problem with short salt
      and password\, fast)

!desc(MD5 crypt) -> password hashing UNIX
!answ(longer password\, 1000 iter slow\, 12-48bit salt\,
      problem with constant cost)

!desc(bcrypt) -> password hashing UNIX
!answ(long salt and password\, variable cost)

!diff(/etc/shadow vs /etc/password) -> stored info
!answ(shadow: hashed password + various dates,
      passwd: UID\, GID\, home directory\, loginshell)

!expl(Discretionary access control) -> Unix Access Control
!answ(owner of file can change permissions)

!desc(the three categories) -> UNIX access control
!answ(User(owner)\, Group, Other(world))

!desc(the three access rights) -> UNIX access control
!answ(Read\, Write\, Execute)

!desc(order of checking) -> UNIX access control
!answ(Owner group other)

!diff(read vs write vs execute) -> directory permissions in UNIX
!answ(read: list the directory\,
      write: delete\, rename and insert files,
      execute: access directory and its files)

!diff(4 vs 2 vs 1) -> chmod permissions
!answ(4: read,
      2: write,
      1: execute)

!expl(setuid and setgid) -> UNIX programs
!answ(is controlled invocation\, temporarily change access right to owners
      by escalation\, x replaced by s)

!expl(setuid and setgid) -> UNIX directories
!answ(setuid usually ignored on directories\, setgid on dir makes new
      files in dir part of dir group (easier file sharing))

!desc(how to set uid and gid) -> chmod
!answ(uid: chmod 4XXX file,
      gid: chmod 2XXX file)

!desc(sticky bit) -> UNIX access control
!answ(previous for keeping code in memory on exit now used to signal
      that owner, dir owner and su can delete file)

!desc(Default Access Rights (umask)) -> UNIX access control
!answ(umask specifies default excluded permissions\, final access
      = full acces AND_NOT(umask)\, ex 0027 removes write from group
      and all from other)

!expl(measures to avoid root escalation) -> chown and chgrp
!answ(only root can change owner, setu/gid bits removed on changed owner\,
      anyone can change group to own group but setu/gid bits removed)

!desc(contents of inode) -> UNIX file system
!answ(access rights\, owner\, group\, last acces/mod/change\,
      size of file\, data block pointers more info through (stat))

!desc(solutions to race condition) -> file creation
!answ(unpredictable filename\, O_EXCL flag (don't open if exists)\,
      check symbolic link lstat())

!diff(nosuid vs noexec vs nodev vs ro) -> mounting file systems UNIX
!answ(nosuid: turn off SUID and SGID bits,
      noexec: no binaries can be exetued,
      nodev: no devices can be accessed
      ro: read only)
