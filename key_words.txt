#use EIT060_words.txt

UMTS, extent of nonrepudation
buffer overflow, unsafe functions, return address, buffer size
spoofing attack, prevention, detection
WEP, confidentiality, integrity, authentication
UID, real, effective, Linux
policy conflict, groups, Linux vs Windows
difference, Bell-LaPalda, Biba
ESP-package, encryption, ip-header, tunnel mode, transport mode
firewall, packet filter, stateful packet filter
orange book vs Common criteria, product functionality, product assurance
SSL, 3x2 keys, Client, Server, CA
Needham-Schroeder, security flaw
Kerberos
cryptographic strength, empirically secure, provably secure, unconditionally secure
Birtday paradox
Messenger Authentication Code (MAC)
FFR (biometric systems)
inference (statistics database)
Chinese wall security model.

diff, access control list, capabilities
drwxrwxrwt vs drwxrwxrwx
Orange Book vs ITSEC vs Common Criteria: functionality, assurance -> products
replay attack, protection in SSL handshake
Encrypt Key Exchange (EKE), omit password, modified EKE
ESP header, ?not encrypted in IPsec transport mode
IDS (Intrusion Detection System), missuse detection, anomaly detection
IDS (Intrusion Detection System) vs honeypot: false negatives, false positives
Biba -> !x(clean, dirty)
RSA, public modulus, public exponent, break-find private exponent
Diffie-Hellman, !desc(), !desc(man in the middle), !desc(stop Diffie-Hellman man in the middle)
!diff(/etc/passwd, /etc/shadow)
!diff(LM, NTLM)hashes.
!diff(Linux vs Windows) -> salt use
!expl(random salt) -> protection time-memory attack
!defi(both entries, channel, authenticated)
!expl(network authenticated) -> UMTS
!expl(server authentication, SSL) -> RSA as handshake
!expl(Controlled Invocation)
!expl(HMAC)
!expl(Chinese Wall Model)
!expl(Spoofing Attack)
!expl(Canary Value)

!expl(benefit known randomness) -> [initialization vectors (IV), salt, nonce]
!expl(lack of authentication of client) -> SSL/TLS webpage
!desc(two security differences) -> [LM,NTLM]
!desc(ss-property, *-property, ds-property) -> Bell-LaPadula
!desc(canary value) -> detecting a buffer overflow attack
!desc(buffer overflow prevention)
!diff(tunnle vs transport)-mode ->  IPsec
!expl(IPsec protects, replay attacks)
!diff(anomaly, missuse)-detection -> IDS
!diff(Orang book vs ITSEC vs Common Creteria) -> [functionality, assurance]
!expl(WEP,CRC-32,ICV,RC4) -> integrity protection
!expl(attacker chosen challenge) -> [[TMTO,MITM]-attack],HMAC]
!expl(known challenge not sufficient) -> TMTO-attack
!expl(challenge,HMAC,random number addition) -> change in protocol security
!expl(startpoint,endpoint,function) -> [TMTO, rainbow]-tables
!desc(largest password can be broken, online attack) -> [T=2^24,M=2^24]
!expl(PBKDF2()) -> improved security of protocol
!expl([primage,second preimage, collision]-resistance]) -> n-bit hash function
!desc(inputs <-> collision) -> n-bit hash function
!desc(inputs <-> second preimage) -> n-bit hash function
!expl(ruid) -> process executes rwsrwxrwx alice:root prog
!expl(euid) -> process executes rwsrwxrwx alice:root prog
!expl(delete permissions) -> -rwsrwzrwx alice:root prog
!expl(listing of new non-exec file) -> umask 027
!expl(x) -> -rwsrwxrwx
!desc(Reference monitor)
!desc(Clark-Wilson)
!desc(CBS mode)
!desc(Security descriptor)
!desc(inode)

#--- Slides ----

#--- Lecture #1 ---

!diff(ITSEC vs Clark and Wilson vs Oragne Book) -> Integrity
!answ(ITSEC: prevent unauthorized writing,
      Clark and Wilson: never possible to destroy/corrupt co. assets or data,
      Organge book: Statebased\, exists when data == source and never exposed to alteration or destruction)

!desc(Integrity) -> communications
!answ(dete. and corr. inte. or rand. mod. in trans.)

!desc(Integrity) -> general case
!answ(ever. should be as it is supp. to be.)

!desc(four ways to achi. integerity)
!answ(CRCs, hash funcs., Mess. Auth. Codes, digi. sigs.)

!expl(Accountability) -> Orange Book
!answ(aduit, possible to trace security actions to responsible party)

!expl(Nonrepudiation of-[ origin, receipt])
!answ(Origin: can't deny sending information,
      Reciept: can't deny receiving information)


#--- Lecture #2 - #3 (13*4 = 52 slides) ---
#layout:
#  * Cryptography
#    * Keys
#      - symmetric
#      - public
#      * security
#        - RSA
#    * Primitives
#    * Encryption strength
#    * Plain- and cipher-text
#    * Ciphers
#      - Vigenere
#      - substitution
#      - one-time-pad
#      - stream
#      - block
#    * Hash functions
#    * Message Authentication Codes (MAC)
#      - properties
#    * Signatures
#    * Certificates

!expl([Empirically,Provably,Unconditionally]-secure -> Encryption mechanics strength.
!answ(Empirically: No one has broken it for some time,
      Provably: Breaking at least as hard as other common problem,
      Unconditionally: Secure with unlimited data-power)

!desc([Plain,Cipher]-text)
!answ(Plain: the text that user wants to send,
      Cipher: the actual text that gets sent)

!expl(Stream cipher)
!answ(Short random key is expanded to long (pseudo)random bit sequence)

!expl(Block cipher)
!answ(Substitution with larger tables\, map text- to cipher-symbols with math)

!diff(ECB vs CBC) -> cipher encryption.
!answ(Electronic Code Book: each block encrypted in isolation\, redundancy,
      Cipher Block Chaining: previous block input to current\, redundancy gone)

!expl(Public key- or asymmetric-cryptography) -> encryption and decryption
!answ(2x keys\, public=encrypt\, private=decrypt)

!expl(Public key- or asymmetric-cryptography) -> digital signatures
!answ(2x keys\, public=verification\, private=signing)

!desc(Defining properties of a hash funciton)
!answ(Easy to compute\, compression arbitrary to fixed length)

!desc(Preimage resistance / one-way) -> Hash function
!answ(infeasible to reconstruct x from y h(x)=y)

!desc(Second preimage resistance / weak collision resistance) -> Hash function
!answ(given x and h(x)\, infeasible to find x' such that h(x)=h(x'))

!desc(Collision resistance / strong collision resistance) -> Hash function
!answ(infeasible to find x, x' such that h(x)=h(x'))

!desc(keyed hash function) -> MAC
!answ(Computed from message and key)

!desc(Purpose of MAC?)
!answ(Proves integrity of message)

!expl(Ease of computation,Compression,Computation resistance) -> MAC properties
!answ(Ease of computation: given k and x, h_k(x) easy to compute,
      Compression: arbitrary input length to fixed output length,
      Computation resistance: given pairs x_p, h_k(x_i) infeasible to compute
                              pair (x, h_k(x)) with new message x)

!expl(nonrepudiation)
!answ(An action should be tied to a unique individual)

!desc(Public verification key) -> RSA signatures
!answ(n,d)

!desc(Private signing key) -> RSA signatures
!answ(e,p,q)

!desc(Signing) -> RSA signatures
!answ(Hash message M: m=h(M) and sign y s= m^e mod n)

!desc(Verification given s and m) -> RSA signatures
!answ(check if s^d = m mod n)

!diff([symmetric vs asymmetric]-algorithms) -> speed
!answ(symmetric are ~ x1000 faster)

!diff([symmetric vs asymmetric]-algorithms) -> security
!answ(Asymmetric key of 1024 ~= 80 symmetric)

!diff(MAC vs digital signaturs) -> keys
!answ(MAC: secret key can sign and verify,
      Signature: One can sign all can verify)

!expl(MAC, Digital Signatures) -> prerequisites for usage
!answ(MAC: pre-shared key,
      Digital Signatures: digital certificates)

# --- lecture 4 - Indentification and Authentication (10x4 + 1 = 41) ---
#layout: 
#* Username
#* Password 
#  - password file
#  - salting
#* Attacks
#  - spoofing
#  - brute force
#  - dictionary
#  - time memory trade off (TMTO)
#  - rainbow table
#* Biometrics
#  - False Acceptance Rate
#  - False Rejection Rate

!desc(unilateral authentication) -> username and password
!answ(System can authenticate user but not reverse)

!desc(prevention methods) -> spoofing attacks
!answ(Trusted path (CTRL+ALT+DEL)\, mutual authentication\, one time passwords)

!desc(detection methods) -> spoofing attacks
!answ(Information about previous login sessions\, display number of failed logins)

!expl(brute force attack) 
!answ(try entering or hashing all possible passwords)

!desc(prevention methods) -> brute force attacks
!answ(have a slow hash function)

!expl(dictionary attack)
!answ(try combinations of different words from dictionaries) 

!expl(time-memory tradeoff attack)
!answ(bruteforce with a precomputed table in memory for faster lookup)

!desc(phases of a TMTO)
!answ(1: preprocessing phase,
      2: realtime/online phase)

!desc(reduction function) -> TMTO
!answ(Not actual reverse of hash\, map hashvalue to plaintext)

!expl(the matrix stopping rule) -> TMTO
!answ(mt^2=N where N is the search space size)

!desc(realtime phase) -> TMTO
!answ(1: Use R(h(R(h(x))))... on hash until endpoint is found,
      2: Iterate over h\->R cycle until h(x) is encounter\, previous x is password)

!desc(Realtime computation needed) -> TMTO
!answ(T=t^2)

!desc(Preprocessing time needed) -> TMTO
!answ(P=N)

!desc(Memory needed) -> TMTO
!answ(M=mt)

!diff(Rainbow Tables vs TMTO)
!answ(Rainbow tables use different R-func for each link in a chain) 

!desc(advantages) -> salting passwords
!answ(1: slows dictionary attacks with several passwords at once,
      2: Attacker needs Rainbow table for each salt,
      3: same password different hash)

# --- lecture 5 - Access Control (4x6 + 3 = 27) ---
#layout:
#*Subject 
#*Objects
#*Access operations
#*Access control structures
#*Intermediate controls

!expl(subject,object,access operation,reference monitor) -> Access Control
!answ(subject: active ex. users and processes,
      object: passive ex. files and resources,
      access operation: ex. read and write,
      reference monitor: grants/denies access)

!diff(execute vs append vs read vs write) -> observe and alter in Bell-LaPadula
!answ(execute: [ ] [ ],
      append: [ ] [x],
      read: [x] [ ],
      write: [x] [x])

!expl(read,write,execute) -> File in Linux
!answ(read: read file,
      write: write file,
      execute: execute program)

!expl(read,write,execute) -> Directory in Linux
!answ(read: list directory,
      write: create/delete/rename files,
      execute: search directory)

!expl([discretionary,mandatory]-{access control}) -> General security policy
!answ(discretionary: owner of object decides access rights,
      mandatory: system decides access rights)

!expl([discretionary,mandatory]-{access control}) -> Orange Book
!answ(discretionary: restrict access based on identity of subject,
      mandatory: restrict access based on information sensitivity of object
                 and authorization level of subject)

!diff(Capabilities vs Access Control List) -> Access Control Matrix
!answ(capabilities: stor access rights with subjects,
      access control list: stor access rights with objects)

!expl(drawbacks) -> capabilities and access control list
!answ(capabilities: difficult to determine who has access to given object,
      access control list: difficult to determine single users permission)

!expl(Principle of least privilege)
!answ(a subject should only have access to necessary resources)

!expl(Separation of duties)
!answ(critical security functions must be preformed by more than one user)

!expl(Role-base access control)
!answ(derive access from users current role)

!desc(RBAC0)
!answ(contains user\, roles\, permission and session)

!desc(RBAC1)
!answ(allows inheritance)

!expl(mutually exclusive roles, cardinality, prerequisite) -> RBAC2
!answ(mutually exclusive roles: separation of duties,
      cardinality: restrictions such as one manager per project or
                   max number of roles per user,
      prerequisite: need to have a previous role possible to implement
                    principle of least privileged)

!desc(RBAC3)
!answ(RBAC1+RBCA2 combining inheritance with constraints)

!expl(domination) -> Lattice of security levels
!answ(b dominates a if a <= b\, a is a subset of b)

!expl(least upper bound: u) -> Lattice of security levels
!answ(least upper bound is the nearest element that contains the elements\,
      if a={x} and b={z} then u={x,z})

!expl(greatest lower bound: l) -> Lattice of security levels
!answ(greatest lower bound is nearest common sub-element\,
      if a={x,y} and b={x,z} then l={x})

!expl(Reference monitor)
!answ(abstract machinery that controls all access to objects)

!expl(Security kernel)
!answ(hardware\, software etc that implements reference monitor concept)

!expl(Trusted computing base)
!answ(set of all protection mechanisms enforcing security policy)

!desc(requirements) -> Reference monitor
!answ(Tamper proof\, always invoked\, allow analysis by being small)

!expl(Controlled invocation) -> users access rights
!answ(supply elevated actions through API that does predefined set of operations)
